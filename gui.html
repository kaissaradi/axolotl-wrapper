<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axolotl Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
        }
        .table-header { background-color: #374151; }
        .table-row-even { background-color: #1f2937; }
        .table-row-odd { background-color: #111827; }
        .table-row-selected { background-color: #4f46e5; }
        .btn {
            background-color: #4f46e5;
            transition: background-color 0.2s;
        }
        .btn:hover { background-color: #6366f1; }
        .btn-secondary {
            background-color: #4b5563;
        }
        .btn-secondary:hover {
            background-color: #6b7280;
        }
        .progress-bar-container {
            background-color: #374151;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .progress-bar {
            background-color: #4f46e5;
            transition: width 0.3s ease-in-out;
        }
        .plot-bg { background-color: #1f2937 !important; }
        .plotly .grid { stroke: rgba(255, 255, 255, 0.1) !important; }
        .plotly .zeroline { stroke: rgba(255, 255, 255, 0.2) !important; }
    </style>
</head>
<body class="p-4">
    <div id="app" class="max-w-screen-2xl mx-auto">
        <header class="mb-6">
            <h1 class="text-4xl font-bold text-white">axolotl Pro</h1>
            <p class="text-lg text-gray-400">High-performance spike sorting refinement with pre-computation.</p>
        </header>

        <!-- Step 1: Directory Selection -->
        <div id="welcome-screen" class="text-center bg-gray-800 p-8 rounded-lg shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 text-white">Welcome to Axolotl Pro</h2>
            <p class="mb-6 text-gray-300">Select your Kilosort output directory to begin.</p>
            <button id="load-dir-btn" class="btn text-white font-bold py-3 px-6 rounded-lg text-lg">
                Load Kilosort Directory
            </button>
            <input type="file" id="file-picker" webkitdirectory directory multiple style="display: none;" />
        </div>

        <!-- Step 2: Pre-computation / Indexing -->
        <div id="indexing-screen" class="hidden bg-gray-800 p-8 rounded-lg shadow-lg">
            <h2 class="text-2xl font-semibold mb-2 text-white">One-Time Pre-computation</h2>
            <p id="indexing-message" class="mb-4 text-gray-300">Optimized snippet cache not found. Pre-computation is required for real-time performance.</p>
            <button id="start-indexing-btn" class="btn text-white font-bold py-3 px-6 rounded-lg text-lg mb-6">Start Pre-computation</button>
            <div id="indexing-progress" class="hidden">
                <div class="progress-bar-container w-full h-4 mb-2">
                    <div id="progress-bar" class="progress-bar h-full" style="width: 0%;"></div>
                </div>
                <p id="progress-text" class="text-center text-gray-400">Initializing...</p>
                <div id="progress-log" class="mt-4 bg-gray-900 rounded-md p-4 h-48 overflow-y-auto text-sm font-mono text-gray-400"></div>
            </div>
        </div>

        <!-- Step 3: Main Application UI -->
        <div id="main-app" class="hidden">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Left Panel: Cluster Table -->
                <div class="lg:col-span-1 bg-gray-800 p-4 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-4 text-white">Clusters</h3>
                    <div class="flex gap-2 mb-4">
                        <button id="filter-good-btn" class="btn-secondary text-white font-bold py-2 px-4 rounded-md w-full">Filter 'Good'</button>
                        <button id="reset-view-btn" class="btn-secondary text-white font-bold py-2 px-4 rounded-md w-full">Reset View</button>
                    </div>
                    <div class="overflow-y-auto" style="max-height: 75vh;">
                        <table class="w-full text-left text-sm">
                            <thead class="sticky top-0">
                                <tr>
                                    <th class="p-2 table-header">ID</th>
                                    <th class="p-2 table-header">KSLabel</th>
                                    <th class="p-2 table-header">Spikes</th>
                                    <th class="p-2 table-header">ISI %</th>
                                </tr>
                            </thead>
                            <tbody id="cluster-table-body">
                                <!-- Rows will be inserted here by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Right Panel: Visualizations -->
                <div class="lg:col-span-2 space-y-6">
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                        <div id="waveform-plot"></div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                            <div id="isi-plot"></div>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                            <div id="spatial-plot"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// --- DATA SIMULATION & MOCKING ---
// In a real application, this data would come from the Kilosort files.
// Here, we simulate it to make the demo runnable.
const AppState = {
    isDataLoaded: false,
    spike_times: null,
    spike_clusters: null,
    channel_positions: null,
    cluster_info: null,
    precomputedCache: {},
    sampling_rate: 30000,
    n_channels: 384,
    cluster_df: [],
    original_cluster_df: [],
    selected_cluster_id: null,
};

function simulateKilosortData() {
    const n_spikes = 500000;
    const n_clusters = 50;
    const max_time = 1800 * AppState.sampling_rate; // 30 minutes

    AppState.spike_times = np.sort(np.random.randint(0, max_time, n_spikes));
    AppState.spike_clusters = np.random.randint(0, n_clusters, n_spikes);
    
    // Simulate a dense probe layout
    const x_coords = np.tile(np.array([0, 20, 40, 60]), AppState.n_channels // 4);
    const y_coords = np.repeat(np.arange(0, AppState.n_channels // 4 * 20, 20), 4);
    AppState.channel_positions = np.vstack([x_coords, y_coords]).T;

    const cluster_ids = np.arange(n_clusters);
    const kslabels = np.random.choice(['good', 'mua', 'noise'], n_clusters, p=[0.4, 0.5, 0.1]);
    AppState.cluster_info = cluster_ids.map((id, i) => ({ cluster_id: id, KSLabel: kslabels[i] }));
    
    console.log("Simulated Kilosort data generated.");
}

// --- NUMPY-LIKE HELPER ---
// A tiny subset of numpy functions to make logic more readable
const np = {
    random: {
        choice: (arr, size, replace = true) => {
            const result = [];
            for (let i = 0; i < size; i++) {
                const index = Math.floor(Math.random() * arr.length);
                result.push(arr[index]);
            }
            return result;
        },
        randint: (low, high, size) => Array.from({ length: size }, () => Math.floor(Math.random() * (high - low)) + low),
        randn: (...dims) => {
            const tensor = (d) => d.length > 1 ? Array.from({length: d[0]}, () => tensor(d.slice(1))) : Array.from({length: d[0]}, Math.random);
            return tensor(dims);
        },
    },
    sum: (arr) => arr.reduce((a, b) => a + b, 0),
    mean: (arr) => np.sum(arr) / arr.length,
    sort: (arr) => [...arr].sort((a, b) => a - b),
    diff: (arr) => {
        const result = [];
        for (let i = 1; i < arr.length; i++) {
            result.push(arr[i] - arr[i-1]);
        }
        return result;
    },
    unique: (arr) => [...new Set(arr)],
    where: (arr, condition) => arr.map((val, i) => condition(val) ? i : -1).filter(i => i !== -1),
    argmax: (arr) => arr.indexOf(Math.max(...arr)),
    arange: (start, stop, step = 1) => Array.from({ length: (stop - start) / step }, (_, i) => start + i * step),
    vstack: (arrays) => {
        const result = [];
        for (let i = 0; i < arrays[0].length; i++) {
            const row = [];
            for (let j = 0; j < arrays.length; j++) {
                row.push(arrays[j][i]);
            }
            result.push(row);
        }
        return result;
    },
    tile: (arr, reps) => Array.from({length: reps}, () => arr).flat(),
    repeat: (arr, reps) => arr.map(val => Array(reps).fill(val)).flat(),
};

// --- CORE APPLICATION LOGIC ---

class DataManager {
    static buildClusterDataFrame() {
        const unique_clusters = np.unique(AppState.spike_clusters);
        const cluster_data = unique_clusters.map(id => {
            const spike_indices = np.where(AppState.spike_clusters, c => c === id);
            const n_spikes = spike_indices.length;
            const info = AppState.cluster_info.find(c => c.cluster_id === id) || { KSLabel: 'unsorted' };
            
            const cluster_spikes = spike_indices.map(i => AppState.spike_times[i]);
            const isi_violations_pct = this._calculateISIViolations(cluster_spikes);

            return {
                cluster_id: id,
                KSLabel: info.KSLabel,
                n_spikes: n_spikes,
                isi_violations_pct: isi_violations_pct
            };
        });
        
        AppState.cluster_df = cluster_data.sort((a, b) => b.n_spikes - a.n_spikes);
        AppState.original_cluster_df = [...AppState.cluster_df];
    }

    static _calculateISIViolations(spike_times, refractory_period_ms = 2.0) {
        if (spike_times.length < 2) return 0.0;
        const sorted_times = np.sort(spike_times);
        const isis = np.diff(sorted_times);
        const refractory_period_samples = (refractory_period_ms / 1000.0) * AppState.sampling_rate;
        const violations = np.sum(isis.map(isi => isi < refractory_period_samples ? 1 : 0));
        return (violations / (spike_times.length - 1)) * 100;
    }

    static getClusterSpikes(cluster_id) {
        return np.where(AppState.spike_clusters, c => c === cluster_id).map(i => AppState.spike_times[i]);
    }
    
    // The new, core pre-computation function
    static async precomputeSnippetsAndEIs(logCallback, progressCallback) {
        const clusters = AppState.original_cluster_df;
        const total = clusters.length;
        
        for (let i = 0; i < total; i++) {
            const cluster = clusters[i];
            const cluster_id = cluster.cluster_id;
            
            await new Promise(resolve => setTimeout(resolve, 20)); // Prevent UI freezing
            logCallback(`Processing Cluster ${cluster_id} (${cluster.n_spikes} spikes)...`);

            const all_spikes = this.getClusterSpikes(cluster_id);
            const sample_size = Math.min(all_spikes.length, 500);
            
            if (sample_size === 0) {
                logCallback(`  -> Skipping cluster ${cluster_id}, no spikes.`);
                progressCallback((i + 1) / total);
                continue;
            }

            // In a real app, this is where you'd call extract_snippets from the .dat file.
            // Here we simulate it.
            const snippets = this._simulateSnippetExtraction(sample_size);
            const mean_ei = this._computeMeanEI(snippets);

            AppState.precomputedCache[cluster_id] = {
                raw_snippets: snippets,
                mean_ei: mean_ei,
            };
            logCallback(`  -> Cached ${sample_size} snippets for cluster ${cluster_id}.`);
            progressCallback((i + 1) / total);
        }
        logCallback("Pre-computation complete! Application is ready.");
    }

    static _simulateSnippetExtraction(n_snippets) {
        // Simulate (n_channels, n_samples, n_spikes)
        const n_samples = 82;
        const snippets = np.random.randn(AppState.n_channels, n_samples, n_snippets);
        // Add a simple waveform shape
        for(let i=0; i < n_snippets; i++) {
            const main_chan = Math.floor(Math.random() * AppState.n_channels);
            for(let t=0; t < n_samples; t++) {
                snippets[main_chan][t][i] -= Math.exp(-Math.pow(t - 40, 2) / 20) * (5 + Math.random() * 5);
            }
        }
        return snippets;
    }

    static _computeMeanEI(snippets) {
        const [n_channels, n_samples, n_spikes] = [snippets.length, snippets[0].length, snippets[0][0].length];
        const mean_ei = Array.from({ length: n_channels }, () => Array(n_samples).fill(0));
        for (let c = 0; c < n_channels; c++) {
            for (let t = 0; t < n_samples; t++) {
                let sum = 0;
                for (let s = 0; s < n_spikes; s++) {
                    sum += snippets[c][t][s];
                }
                mean_ei[c][t] = sum / n_spikes;
            }
        }
        return mean_ei;
    }
}

// --- UI & PLOTTING LOGIC ---

class UIManager {
    static setupEventListeners() {
        document.getElementById('load-dir-btn').addEventListener('click', () => {
            document.getElementById('file-picker').click();
        });
        document.getElementById('file-picker').addEventListener('change', this.handleFileLoad);
        document.getElementById('start-indexing-btn').addEventListener('click', this.startIndexing);
        document.getElementById('filter-good-btn').addEventListener('click', () => this.filterTable('good'));
        document.getElementById('reset-view-btn').addEventListener('click', () => this.renderTable(AppState.original_cluster_df));
    }

    static handleFileLoad(event) {
        if (event.target.files.length > 0) {
            // Simulate loading and show indexing screen
            simulateKilosortData();
            DataManager.buildClusterDataFrame();
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('indexing-screen').classList.remove('hidden');
        }
    }

    static async startIndexing() {
        document.getElementById('start-indexing-btn').classList.add('hidden');
        document.getElementById('indexing-progress').classList.remove('hidden');
        const logEl = document.getElementById('progress-log');
        const progressTextEl = document.getElementById('progress-text');
        const progressBarEl = document.getElementById('progress-bar');

        const logCallback = (msg) => {
            logEl.innerHTML += `<div>${msg}</div>`;
            logEl.scrollTop = logEl.scrollHeight;
        };
        const progressCallback = (progress) => {
            const percent = Math.round(progress * 100);
            progressBarEl.style.width = `${percent}%`;
            progressTextEl.textContent = `Indexing... ${percent}% complete`;
        };

        await DataManager.precomputeSnippetsAndEIs(logCallback, progressCallback);

        // Transition to main app
        setTimeout(() => {
            document.getElementById('indexing-screen').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');
            this.renderTable(AppState.cluster_df);
        }, 1000);
    }

    static renderTable(data) {
        const tableBody = document.getElementById('cluster-table-body');
        tableBody.innerHTML = '';
        data.forEach((row, i) => {
            const tr = document.createElement('tr');
            tr.className = `cursor-pointer hover:bg-gray-600 ${i % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`;
            if(AppState.selected_cluster_id === row.cluster_id) {
                tr.classList.add('table-row-selected');
            }
            tr.innerHTML = `
                <td class="p-2">${row.cluster_id}</td>
                <td class="p-2">${row.KSLabel}</td>
                <td class="p-2">${row.n_spikes}</td>
                <td class="p-2">${row.isi_violations_pct.toFixed(2)}</td>
            `;
            tr.addEventListener('click', () => this.handleClusterSelection(row.cluster_id));
            tableBody.appendChild(tr);
        });
    }

    static filterTable(kslabel) {
        const filtered_data = AppState.original_cluster_df.filter(c => c.KSLabel === kslabel);
        this.renderTable(filtered_data);
    }

    static handleClusterSelection(cluster_id) {
        AppState.selected_cluster_id = cluster_id;
        this.renderTable(AppState.cluster_df); // Re-render to show selection
        this.updateAllPlots(cluster_id);
    }
    
    static updateAllPlots(cluster_id) {
        const features = AppState.precomputedCache[cluster_id];
        if (!features) {
            console.error(`No precomputed data for cluster ${cluster_id}`);
            return;
        }
        
        this.plotWaveforms(cluster_id, features);
        this.plotISI(cluster_id);
        this.plotSpatial(cluster_id, features);
    }

    static plotWaveforms(cluster_id, features) {
        const { raw_snippets, mean_ei } = features;
        const n_samples = mean_ei[0].length;
        const time_axis = np.arange(0, n_samples).map(t => (t - 40) / AppState.sampling_rate * 1000);
        
        // Find dominant channel from mean EI
        const p2p = mean_ei.map(channel_wfs => Math.max(...channel_wfs) - Math.min(...channel_wfs));
        const dom_chan = np.argmax(p2p);

        const traces = [];
        // Raw snippets
        const n_raw_to_show = Math.min(30, raw_snippets[0][0].length);
        for (let i = 0; i < n_raw_to_show; i++) {
            traces.push({
                x: time_axis,
                y: raw_snippets[dom_chan].map(t => t[i]),
                mode: 'lines',
                line: { color: 'rgba(200, 200, 200, 0.1)' },
                hoverinfo: 'none'
            });
        }
        // Mean EI
        traces.push({
            x: time_axis,
            y: mean_ei[dom_chan],
            mode: 'lines',
            line: { color: '#6366f1', width: 3 },
            name: 'Mean EI'
        });

        const layout = {
            title: `Cluster ${cluster_id}: Dominant Channel Waveforms`,
            xaxis: { title: 'Time (ms)', gridcolor: '#374151', zerolinecolor: '#4b5563' },
            yaxis: { title: 'Amplitude (uV)', gridcolor: '#374151', zerolinecolor: '#4b5563' },
            showlegend: false,
            paper_bgcolor: '#1f2937',
            plot_bgcolor: '#1f2937',
            font: { color: '#d1d5db' }
        };
        Plotly.newPlot('waveform-plot', traces, layout, {responsive: true});
    }
    
    static plotISI(cluster_id) {
        const spikes = DataManager.getClusterSpikes(cluster_id);
        const isis_ms = np.diff(np.sort(spikes)).map(s => s / AppState.sampling_rate * 1000);
        
        const trace = {
            x: isis_ms,
            type: 'histogram',
            xbins: { start: 0, end: 50, size: 1 },
            marker: { color: '#4f46e5' }
        };
        
        const layout = {
            title: `Cluster ${cluster_id}: ISI Histogram`,
            xaxis: { title: 'ISI (ms)', gridcolor: '#374151' },
            yaxis: { title: 'Count', gridcolor: '#374151' },
            bargap: 0.05,
            paper_bgcolor: '#1f2937',
            plot_bgcolor: '#1f2937',
            font: { color: '#d1d5db' },
            shapes: [{
                type: 'line',
                x0: 2, x1: 2, y0: 0, y1: 1, yref: 'paper',
                line: { color: '#ef4444', width: 2, dash: 'dash' }
            }]
        };
        Plotly.newPlot('isi-plot', [trace], layout, {responsive: true});
    }
    
    static plotSpatial(cluster_id, features) {
        const { mean_ei } = features;
        const p2p = mean_ei.map(wfs => Math.max(...wfs) - Math.min(...wfs));
        const dom_chan = np.argmax(p2p);
        
        // Find 16 nearest neighbors
        const distances = AppState.channel_positions.map(pos => 
            Math.sqrt(Math.pow(pos[0] - AppState.channel_positions[dom_chan][0], 2) + Math.pow(pos[1] - AppState.channel_positions[dom_chan][1], 2))
        );
        const neighbor_indices = np.sort(np.arange(0, distances.length).map(i => ({i, d: distances[i]})), (a,b) => a.d - b.d)
            .slice(0, 16).map(item => item.i);
        
        const traces = [];
        const time_axis = np.arange(0, mean_ei[0].length).map(t => (t - 40) / AppState.sampling_rate * 1000);
        
        const max_abs = Math.max(...mean_ei.flat().map(Math.abs));
        const y_scale = 0.05;
        const x_scale = 15;

        neighbor_indices.forEach(ch_idx => {
            const [x_pos, y_pos] = AppState.channel_positions[ch_idx];
            traces.push({
                x: time_axis.map(t => t * x_scale + x_pos),
                y: mean_ei[ch_idx].map(v => v * y_scale + y_pos),
                mode: 'lines',
                line: { 
                    color: ch_idx === dom_chan ? '#6366f1' : 'rgba(200, 200, 200, 0.5)',
                    width: ch_idx === dom_chan ? 2 : 1.5
                },
                hoverinfo: 'none'
            });
        });
        
        const layout = {
            title: `Cluster ${cluster_id}: Spatial Waveforms`,
            showlegend: false,
            xaxis: { visible: false, range: [Math.min(...AppState.channel_positions.map(p=>p[0]))-50, Math.max(...AppState.channel_positions.map(p=>p[0]))+50] },
            yaxis: { visible: false, scaleanchor: "x", scaleratio: 1 },
            paper_bgcolor: '#1f2937',
            plot_bgcolor: '#1f2937',
            font: { color: '#d1d5db' },
        };
        Plotly.newPlot('spatial-plot', traces, layout, {responsive: true});
    }
}

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', () => {
    UIManager.setupEventListeners();
});

</script>
</body>
</html>
